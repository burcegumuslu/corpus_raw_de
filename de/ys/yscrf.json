{"title": "PDF", "author": "PDF", "url": "https://sp1819.github.io/objektorientierungIII.pdf", "hostname": "PDF", "description": "PDF", "sitename": "PDF", "date": "PDF", "id": "PDF", "license": "PDF", "body": "PDF", "comments": "PDF", "commentsbody": "PDF", "raw_text": "PDF", "text": "Objektorientiertes Programmieren III\nSymbolische Programmiersprache\nBenjamin Roth and Annemarie Friedrich\nWintersemester 2016/2017\nCentrum f\u00fcr Informations- und Sprachverarbeitung\nLMU M\u00fcnchen\n1Recap: Klassen = Baupl\u00e4ne\n\u2022Klassen sind Baupl\u00e4ne/Designs f\u00fcr Objekte .\n\u2022Objekte mit Hilfe von Klassen erstellen: Wir instanziieren objects.\nObjekte = Instanzen einer Klasse.\n\u2022Objekte einer Klasse haben die gleiche grundlegende Struktur,\nk\u00f6nnen sich aber in verschiedenen Aspekten unterscheiden.\n2Recap: Vererbung\n\u2022Verschiedene Objekte haben teilweise dasselbe Verhalten /\ndieselben Charakteristika.\n\u2022Vererbung !Code-Dopplungen vermeiden.\n3Beispiel Bank\n\u2022Sparkonto : F\u00fcr jedes Konto werden Kontonummer,\nKontoinhaber und Kontostand gespeichert. Der Kontostand\nmuss\u00150sein. Eine Zinsrate, die f\u00fcr alle Sparkonten gemeinsam\nde\ufb01niert ist, kann angewendet werden. Auf das Konto kann Geld\neingezahlt werden. Der Kontoauszug (der ausgedruckt werden\nkann) beinhaltet die Kontonummer, den Kontoinhaber und den\nKontostand.\n\u2022Girokonto :F\u00fcr jedes Konto werden Kontonummer, Kontoinhaber\nund Kontostand gespeichert. Der Kontostand muss innerhalb\ndem f\u00fcr jeden Kunden separat de\ufb01nierten Kreditrahmen liegen.\nWenn der Kreditrahmen von Anne $500 ist, darf ihr Kontostand\nminimal -$500 betragen. Auf das Konto kann Geld eingezahlt\nwerden. Der Kontoauszug (der ausgedruckt werden kann)\nbeinhaltet die Kontonummer, den Kontoinhaber und den\nKontostand.\nKlassendesign: Tafel4Gemeinsamkeiten/Generelle Funktionalit\u00e4t: \u00dcberklasse\n1class Account :\n2 ''' aclass providing general\n3 functionality for accounts '''\n4 #CONSTRUCTOR\n5 def __init__ (self , num, person):\n6 self .balance = 0\n7 self .number = num\n8 self .holder = person\n9 #METHODS\n10 def deposit (self , amount):\n11 self .balance += amount\n12 def withdraw (self , amount):\n13 ifamount > self .balance:\n14 amount = self .balance\n15 self .balance -= amount\n16 return amount\n17 def __str__ (self ):\n18 res = ...\n19 return res\n5Spezialf\u00e4lle: Unterklassen\n\u2022SavingsAccount \u201cbasiert auf\u201d\nAccount\n\u2022Methoden der \u00dcberklasse sind in\nderUnterklasse (und\nInstanzobjekten der Unterklasse)\nverf\u00fcgbar\n1annesAcc = SavingsAccount(1, \"Anne \")\n2annesAcc.deposit(200)\n3annesAcc.apply_interest()\n4print (annesAcc)\n6Spezialf\u00e4lle: Unterklassen\n\u2022SavingsAccount isbased on Account\n\u2022SavingsAccount isderived from Account\n\u2022SavingsAccount extends Account\n\u2022Methoden der \u00dcberklasse sind in der Unterklasse (und\nInstanzobjekten der Unterklasse) verf\u00fcgbar\n\u2022SavingsAccount stellt zus\u00e4tzliche Funktionalit\u00e4t bereit\n1class SavingsAccount (Account):\n2 ''' class for objects representing savings accounts .\n3 shows how aclass can beextended .'''\n4 interest_rate = 0.035\n5 #METHODS\n6 def apply_interest (self ):\n7 self .balance *= (1+SavingsAccount.interest_rate)\n7Methoden \u00fcberschreiben\n\u2022DieAccount -Klasse hat auch\n__init__ andwithdraw\nMethoden\n\u2022DieCheckingAccount -Klasse\n\u00fcberschreibt diese\n1annesAcc = CheckingAccount(1,\n2 \"Anne \", 500)\n3annesAcc.deposit(200)\n4annesAcc.withdraw(350)\n5print (annesAcc)\nWelche Methoden werden\naufgerufen?\n\u2022__init__\n\u2022deposit\n\u2022withdraw\n\u2022__str__8Methoden \u00fcberschreiben\n\u2022DieAccount -Klasse hat auch __init__ andwithdraw Methoden\n\u2022DieCheckingAccount -Klasse \u00fcberschreibt diese\n1class CheckingAccount (Account):\n2 #CONSTRUCTOR\n3 def __init__ (self , num, person, credit_range):\n4 print (\"Creating acheckings account \")\n5 self .number = num\n6 self .holder = person\n7 self .balance = 0\n8 self .credit_range = credit_range\n9 #METHODS\n10 def withdraw (self , amount):\n11 amount = min(amount, abs(self .balance \\\n12 +self .credit_range))\n13 self .balance -= amount\n14 return amount\n9Klassenhierarchie\nWelche Methoden wer-\nden ausgef\u00fchrt, wenn\ndie folgenden Methoden\naufannesAcc\noder stefansAcc aufge-\nrufen werden?\n\u2022__init__\n\u2022__str__\n\u2022deposit\n\u2022withdraw\n\u2022apply_interest\n10Polymorphismus\n\u2022\u2019Vielgestaltigkeit\u2019 (Griechisch)\n\u2022Methode wird auf Objekte angewandt !was passiert, h\u00e4ngt von\nder Klassenhierarchie ab\nBeispiel\nAnwendungscode: annesAcc.withdraw(400)\n\u2022Es ist egal, von welchem Typ annesAcc ist\n\u2022Python folgt der Klassenhierarchie und erzeugt das gew\u00fcnschte\nVerhalten\n11Klassenhierarchie: Design\nWir h\u00e4tten auch zwei\nwithdraw -Methoden\nde\ufb01nieren k\u00f6nnen (eine\nin jeder Unterklasse).\nWarum k\u00f6nnte es\nn\u00fctzlich sein, sie in der\nAccount -Klasse zu\nhaben?\n12Redundanz\n\u2022Wenn die Daten f\u00fcr ein Objekt mehrfach existieren (z.B.\nKontoinhaber-Info separat f\u00fcr jedes Konto f\u00fchren)\n)Inkonsistenzen m\u00f6glich\n\u2022Derselbe Code wird mehrfach geschrieben\n)Wartung schwierig\n1class Account :\n2 def __init__ (self , num, person):\n3 self .balance = 0\n4 self .number = num\n5 self .holder = person\n6\n7class CheckingAccount (Account):\n8 def __init__ (self , num, person, credit_range):\n9 self .number = num\n10 self .holder = person\n11 self .balance = 0\n12 self .credit_range = credit_range\n13Redundanzen minimieren\n\u2022Hier: Methode einer \u00dcberklasse aus einer Unterklasse aufrufen\n)Methode der \u00dcberklasse erweitern\n\u2022Methode wird auf der Klasse aufgerufen )Referenz auf\nInstanzobjekt muss hier explizit an self\u00fcbergeben werden\n1class Account :\n2 def __init__ (self , num, person):\n3 self .balance = 0\n4 self .number = num\n5 self .holder = person\n6\n7class CheckingAccount (Account):\n8 def __init__ (self , num, person, credit_range):\n9 Account.__init__( self , num, person)\n10 self .credit_range = credit_range\n14Redundanzen minimieren: weiteres Beispiel\n1class Account :\n2 def withdraw (self , amount):\n3 self .balance -= amount\n4 return amount\n5\n6class SavingsAccount (Account):\n7 def withdraw (self , amount):\n8 ifamount > self .balance:\n9 amount = self .balance\n10 cash = Account.withdraw( self , amount)\n11 return cash\n12\n13class CheckingAccount (Account):\n14 #METHODS\n15 def withdraw (self , amount):\n16 amount = min(amount,\n17 abs(self .balance + self .credit_range))\n18 cash = Account.withdraw( self , amount)\n19 return cash\n15UML Klassendiagramm: Vererbung\n16Mehrfachvererbung\n\u2022In einigen objektorientierten Sprachen (z.B. Java) k\u00f6nnen\nKlassen nur eine einzige Klasse erweitern.\n\u2022In Python kann eine Klasse von mehreren Klassen erben\n)Multiple Inheritance (Mehrfachvererbung)\n\u2022Methodenaufruf !welche Klasse? !spezielle Mechanismen\n\u2022Empfehlung: im Moment max. eine \u00dcberklasse nutzen!\n17Everything in Python is an object\n\u2022Wir benutzen eigentlich die ganze Zeit schon Objekte ...\n\u2022Listen und Dictionaries sind Objekt\n\u2022Erzeugung mit spezieller Syntax (Klassenaufruf auch m\u00f6glich)\n\u2022Strings und Zahlen sind auch Objekte\n1#create anew list object\n2myList = []\n3#call amethod ofthe list object\n4myList.append(4)\n5#create anew dictionary object\n6myDict = {}\n7#call amethod ofthe dictionary object\n8myDict[ \"someKey \"] = \"someValue \"\n\u2022Zeile 8 ruft eine Hook-Methode des Dictionaries auf:\n__setitem__(self, key, value)\n18Everything in Python is an object\n\u2022Wir k\u00f6nnen auch Unterklassen der built-in -Klassen erstellen\n\u2022Hier: Hooks \u00fcberschreiben\n1class TalkingDict (dict ):\n2 #Constructor\n3 def __init__ (self ):\n4 print (\"Starting tocreate anew dictionary ...\")\n5 dict .__init__( self )\n6 print (\"Done !\")\n7 #Methods\n8 def __setitem__ (self , key, value):\n9 print (\"Setting \", key, \"to\", value)\n10 dict .__setitem__( self , key, value)\n11 print (\"Done !\")\n12\n13print (\"Weare going tocreate atalking dictionary !\")\n14myDict = TalkingDict()\n15myDict[ \"x\"] = 42\n19Verst\u00e4ndnis von OOP ist n\u00fctzlich, weil ...\n\u2022Wir programmieren \u201cim wahren Leben\u201d selten from scratch\n\u2022Wir erweitern / modi\ufb01zieren bestehenden Code\n\u2022Framework = Sammlung von (\u00dcber-)Klassen, die h\u00e4u\ufb01ge\nProgrammieraufgaben implementieren\n\u2022Wir m\u00fcssen verstehen, wie die Klassen des Frameworks\nzusammenarbeiten\n\u2022Wir schreiben Unterklassen, die das Verhalten f\u00fcr unseren\nAnwendungsfall spezialisieren\n\u2022Rezepte daf\u00fcr: Design Patterns\n(Design Patterns: Elements of Reusable Object-Oriented Software\nby: Gamma, Helm, Johnson, Vlissides)\n20Terminologie: Datenkapselung (encapsulation)\n\u2022Wird in der OOP-Literatur f\u00fcr zwei Aspekte benutzt:\n1.Daten sollten versteckt sein, Zugriff nur \u00fcber Instanzmethoden\n2.Programm-Logik soll in Schnittstellen (Interfaces)\n(Klassennamen und Methodennamen) so verpackt sein, dass\njede Funktionalit\u00e4t nur einmal de\ufb01niert ist\n21References\nMark Lutz: Learning Python , Part VI, 4th edition, O\u2019Reilly, 2009.\nMichael Dawson: Python Programming for the Absolute Beginner ,\nChapters 8 & 9, 3rd edition, Course Technology PTR, 2010.\n22", "language": "PDF", "image": "PDF", "pagetype": "PDF", "links": "PDF"}