{"title": "Kapitel 19. XML-Mapping", "author": null, "url": null, "hostname": null, "description": null, "sitename": null, "date": "2004-01-01", "id": null, "license": null, "body": null, "comments": "", "commentsbody": null, "raw_text": null, "text": "[Hibernate.org](http://www.hibernate.org) [Community Documentation](http://hibernate.org/Documentation/DocumentationOverview)\nXML Mapping is an experimental feature in Hibernate 3.0 and is currently under active development.\nHibernate allows you to work with persistent XML data in much the same way you work with persistent POJOs. A parsed XML tree can be thought of as another way of representing the relational data at the object level, instead of POJOs.\nHibernate unterst\u00fctzt dom4j als API zur Verarbeitung von XML-B\u00e4umen. Sie k\u00f6nnen Anfragen, die dom4j-B\u00e4ume von der Datenbank abrufen, schreiben, wobei alle Modifikationen am Baum automatisch mit der Datenbank synchronisiert werden. Sie k\u00f6nnen sogar ein XML-Dokument unter Verwendung von dom4j auf die Syntax pr\u00fcfen und mittels Hibernates Grundvorg\u00e4ngen:\npersist(), saveOrUpdate(), merge(), delete(), replicate() (\"Merging\" wird noch nicht unterst\u00fctzt) in die Datenbank schreiben.\nDieses Feature bietet zahlreiche Anwendungen einschlie\u00dflich des Imports/Exports von Daten, Externalisierung von Entity-Daten via JMS oder SOAP und XSLT-basiertem Reporting.\nA single mapping can be used to simultaneously map properties of a class and nodes of an XML document to the database, or, if there is no class to map, it can be used to map just the XML.\nHier ist ein Beispiel f\u00fcr das gleichzeitige Mappen eines POJO und XML:\n<class name=\"Account\"\ntable=\"ACCOUNTS\"\nnode=\"account\">\n<id name=\"accountId\"\ncolumn=\"ACCOUNT_ID\"\nnode=\"@id\"/>\n<many-to-one name=\"customer\"\ncolumn=\"CUSTOMER_ID\"\nnode=\"customer/@id\"\nembed-xml=\"false\"/>\n<property name=\"balance\"\ncolumn=\"BALANCE\"\nnode=\"balance\"/>\n...\n</class\n>\nDieses ist ein Beispiel ohne POJO-Klasse:\n<class entity-name=\"Account\"\ntable=\"ACCOUNTS\"\nnode=\"account\">\n<id name=\"id\"\ncolumn=\"ACCOUNT_ID\"\nnode=\"@id\"\ntype=\"string\"/>\n<many-to-one name=\"customerId\"\ncolumn=\"CUSTOMER_ID\"\nnode=\"customer/@id\"\nembed-xml=\"false\"\nentity-name=\"Customer\"/>\n<property name=\"balance\"\ncolumn=\"BALANCE\"\nnode=\"balance\"\ntype=\"big_decimal\"/>\n...\n</class\n>\nThis mapping allows you to access the data as a dom4j tree, or as a graph of property name/value pairs or java\nMaps. The property names are purely logical constructs that can be referred to in HQL queries.\nA range of Hibernate mapping elements accept the\nnode attribute. This lets you specify the name of an XML attribute or element that holds the property or entity data. The format of the\nnode attribute must be one of the following:\n\"element-name\": map to the named XML element\n\"@attribute-name\": map to the named XML attribute\n\".\": map to the parent element\n\"element-name/@attribute-name\": map to the named attribute of the named element\nFor collections and single valued associations, there is an additional\nembed-xml attribute. If\nembed-xml=\"true\", the default, the XML tree for the associated entity (or collection of value type) will be embedded directly in the XML tree for the entity that owns the association. Otherwise, if\nembed-xml=\"false\", then only the referenced identifier value will appear in the XML for single point associations and collections will not appear at all.\nDo not leave\nembed-xml=\"true\" for too many associations, since XML does not deal well with circularity.\n<class name=\"Customer\"\ntable=\"CUSTOMER\"\nnode=\"customer\">\n<id name=\"id\"\ncolumn=\"CUST_ID\"\nnode=\"@id\"/>\n<map name=\"accounts\"\nnode=\".\"\nembed-xml=\"true\">\n<key column=\"CUSTOMER_ID\"\nnot-null=\"true\"/>\n<map-key column=\"SHORT_DESC\"\nnode=\"@short-desc\"\ntype=\"string\"/>\n<one-to-many entity-name=\"Account\"\nembed-xml=\"false\"\nnode=\"account\"/>\n</map>\n<component name=\"name\"\nnode=\"name\">\n<property name=\"firstName\"\nnode=\"first-name\"/>\n<property name=\"initial\"\nnode=\"initial\"/>\n<property name=\"lastName\"\nnode=\"last-name\"/>\n</component>\n...\n</class\n>\nIn this case, the collection of account ids is embedded, but not the actual account data. The following HQL query:\nfrom Customer c left join fetch c.accounts where c.lastName like :lastName\nwould return datasets such as this:\n<customer id=\"123456789\">\n<account short-desc=\"Savings\"\n>987632567</account>\n<account short-desc=\"Credit Card\"\n>985612323</account>\n<name>\n<first-name\n>Gavin</first-name>\n<initial\n>A</initial>\n<last-name\n>King</last-name>\n</name>\n...\n</customer\n>\nWenn Sie die Einstellung\nembed-xml=\"true\" im\n<one-to-many>-Mapping vornehmen, so sehen die Daten eher wie folgt aus:\n<customer id=\"123456789\">\n<account id=\"987632567\" short-desc=\"Savings\">\n<customer id=\"123456789\"/>\n<balance\n>100.29</balance>\n</account>\n<account id=\"985612323\" short-desc=\"Credit Card\">\n<customer id=\"123456789\"/>\n<balance\n>-2370.34</balance>\n</account>\n<name>\n<first-name\n>Gavin</first-name>\n<initial\n>A</initial>\n<last-name\n>King</last-name>\n</name>\n...\n</customer\n>\nYou can also re-read and update XML documents in the application. You can do this by obtaining a dom4j session:\nDocument doc = ....;\nSession session = factory.openSession();\nSession dom4jSession = session.getSession(EntityMode.DOM4J);\nTransaction tx = session.beginTransaction();\nList results = dom4jSession\n.createQuery(\"from Customer c left join fetch c.accounts where c.lastName like :lastName\")\n.list();\nfor ( int i=0; i<results.size(); i++ ) {\n//add the customer data to the XML document\nElement customer = (Element) results.get(i);\ndoc.add(customer);\n}\ntx.commit();\nsession.close();\nSession session = factory.openSession();\nSession dom4jSession = session.getSession(EntityMode.DOM4J);\nTransaction tx = session.beginTransaction();\nElement cust = (Element) dom4jSession.get(\"Customer\", customerId);\nfor ( int i=0; i<results.size(); i++ ) {\nElement customer = (Element) results.get(i);\n//change the customer name in the XML and database\nElement name = customer.element(\"name\");\nname.element(\"first-name\").setText(firstName);\nname.element(\"initial\").setText(initial);\nname.element(\"last-name\").setText(lastName);\n}\ntx.commit();\nsession.close();\nWhen implementing XML-based data import/export, it is useful to combine this feature with Hibernate's\nreplicate() operation.\nCopyright \u00a9 2004 Red Hat, Inc.", "language": null, "image": null, "pagetype": null, "links": ["http://www.hibernate.org", "http://hibernate.org/Documentation/DocumentationOverview", "filters.html", "performance.html", null, "xml.html#xml-intro", "xml.html#xml-intro-mapping", "xml.html#xml-onlyxml", "xml.html#xml-mapping", "xml.html#xml-manipulation", null, null, null, null, null, "legalnotice.html", "filters.html", "#", "index.html", "performance.html"]}