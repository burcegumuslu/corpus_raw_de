{"title": "PDF", "author": "PDF", "url": "https://wr.informatik.uni-hamburg.de/_media/teaching/sommersemester_2014/cgk-14-threads_michael_strassberger-presentation.pdf", "hostname": "PDF", "description": "PDF", "sitename": "PDF", "date": "PDF", "id": "PDF", "license": "PDF", "body": "PDF", "comments": "PDF", "commentsbody": "PDF", "raw_text": "PDF", "text": "C Grundlagen - Threads\nMichael Strassberger\nsaremox@linux.com\nProseminar C Grundlagen\nFachbereich Informatik\nFakultaet fuer Mathematik, Informatik und Naturwissenschaften\nUniversitaet Hamburg\n3. Juli 2014\nTable of Contents\n1Introduction\n2What are threads\n3How to use threads in C\n4Summary\n5Literature\nC Grundlagen - Threads\nMotivation\nTable of Contents\n1Introduction\n2What are threads\n3How to use threads in C\n4Summary\n5Literature\n3 / 32C Grundlagen - Threads\nMotivation\nProcessing speed is limited\nPhysical Limits\n\u000fElectrical signal speed (RS)\n\u000fCooling the heat\nWorkarounds from Hardware manufactures\n\u000fMultiple CPU Cores  \n\u000fAdvanced IS\n\u000fMMX etc\n4 / 32C Grundlagen - Threads\nMotivation\nTypes of computing problems\nProblems that can be seperated\n\u000fCompression\n\u000fLempelZivMarkov chain algorithm\n\u000fSimulations\n\u000fWeather\n\u000fChemical reactions\n\u000fSatelite movements\n\u000fSort algorithm\n\u000fArithmeticProblems that can`t be seperated\n\u000fFile I/O\n\u000fNetwork I/O\n\u000fHardware Access\n\u000fSound\n\u000fHDD\n\u000fGraphical user Interface\n\u000fGTK\n\u000fQT\n5 / 32Airthmetic Example\n1000X\ni=0(i2+ 5\u0001i+ 5)10\nPart #1\nres1 =500X\ni=0(i2+ 5\u0001i+ 5)10Part #2\nres2 =1000X\ni=501(i2+ 5\u0001i+ 5)10\nJoin parts together\nint result = res1 + res2;C Grundlagen - Threads\nWhat are threads\nTable of Contents\n1Introduction\n2What are threads\nWith great power comes great responsibilitty\n3How to use threads in C\n4Summary\n5Literature\n7 / 32C Grundlagen - Threads\nWhat are threads\nWhat are threads\nDe\fnition\nIn computer science, a thread of execution is the smallest sequence of programmed\ninstructions that can be managed independently by an operating system scheduler. [2]\nProperties of threads\n\u000fSmall memory footprint\n\u000fOS can map threads to di\u000brent CPU`s\n8 / 32C Grundlagen - Threads\nWhat are threads\nHow Unix processes are organized\n0x000000003 GB0xf99999991 GB0x\u000b\u000b\u000b\u000b\nKernel Space\nUser SpaceProcess ID\nUser ID\nGroup IDFiles\nLocks\nSocketsShared Libraries\nData\nText (elf)HeapStackStack pointer\nProgr. Counter\nRegisterStack Stack pointer\nProgr. Counter\nRegister\n[1]9 / 32C Grundlagen - Threads\nWhat are threads\nWith great power comes great responsibillity\nProblems that occur by using threads\n\u000fRace Condition\n\u000fCommunication between threads\n\u000fDead locks\n\u000fLive locks\n10 / 32C Grundlagen - Threads\nWhat are threads\nWith great power comes great responsibilitty\nRace Condition\nThread #1 Thread #2\nRead balanceRead balanceBalance 1000 $\nAdd 200 $Add 350 $\nSave BalanceSave Balance\nBalance 1200 $\nRead Balance\nWithdraw 1550 $Balance -350 $\n11 / 32C Grundlagen - Threads\nWhat are threads\nWith great power comes great responsibilitty\nBut there is hope\nLocks / Mutex\n\u000fprimary implementation for thread syncronisation\n\u000fmutexes can prevent race conditions\n\u000fIt`s up to the programmer to ensure locking and unlocking mutexes\n12 / 32C Grundlagen - Threads\nWhat are threads\nWith great power comes great responsibilitty\nBut wait...\nThread #1 Thread #2\nLock A Lock B\nRead A Read B\nLock B Lock A\nWait for lock B Wait for lock A\n13 / 32C Grundlagen - Threads\nWhat are threads\nWith great power comes great responsibilitty\nSummary\nWhat we now know about threads\n\u000fThreads have a small memory footprint\n\u000fWe`ve to be careful using threads\n\u000fConsistence of shared data\n\u000fSyncronisation\n14 / 32C Grundlagen - Threads\nUsage\nTable of Contents\n1Introduction\n2What are threads\n3How to use threads in C\npthread\nOpenMP\n4Summary\n5Literature\n15 / 32C Grundlagen - Threads\nUsage\nOverview\nLibraries\n\u000fpthread \n\u000fOpenMP \n\u000fc11\n\u000fglib\n\u000fQt-Threads\n\u000fmany more...\n16 / 32C Grundlagen - Threads\nUsage\npthread\nWhat is PThread\nPThread\n\u000fIn History each hardware vendor had developed his own implementation of threads\n\u000fPthread is a standardized programming interface\n\u000fde\fned for unix in IEEE POSIX 1003.1c standard (1995)\n\u000fHardware vendors began to o\u000ber pthread implementations\n17 / 32C Grundlagen - Threads\nUsage\npthread\nCompiling\ngcc\ngcc -std=c11 -lpthread <\fle> -o <output>\nMake\fle\n1Account : account .o\n2 cc -lpthread -O3 account .o -o Account\n3account .o : main .c\n4 cc -std = c11 -c -lpthread -lm -O3 main .c -o account .o\n18 / 32C Grundlagen - Threads\nUsage\npthread\nQuick Overview\nData Types for pthread\n1pthread_t thread\nImportant function calls\n1pthread_create ( thread , attributes , start_routine , argument )\n2pthread_exit ( status )\n3pthread_cancel ( thread )\n19 / 32C Grundlagen - Threads\nUsage\npthread\npthread Example\nHello World\n1void * sayhello ( void * arg )\n2{\n3 long threadID = ( long ) arg ;\n4 fprintf (stdout ,\" Hello from Thread #%d\\n\",threadID );\n5 return 0;\n6}\n7int main ( int argc , char * argv [])\n8{\n9 pthread_t thread [20];\n10 for ( long threadid = 1; threadid < 20; threadid ++)\n11 pthread_create (& thread [ threadid ], NULL ,\n12 sayhello ,( void *) threadid );\n13 pthread_exit ( NULL );\n14}\n20 / 32C Grundlagen - Threads\nUsage\npthread\nOutput\nHello World\n1Hello from Thread #4\n2Hello from Thread #5\n3Hello from Thread #6\n4Hello from Thread #7\n5Hello from Thread #9\n6Hello from Thread #10\n7Hello from Thread #8\n8Hello from Thread #11\n9Hello from Thread #12\n10Hello from Thread #13\n11Hello from Thread #14\n12Hello from Thread #19\n13Hello from Thread #18\n14Hello from Thread #16\n15Hello from Thread #17\n21 / 32C Grundlagen - Threads\nUsage\npthread\npassing Arguments & Joining\nJob Structure\n1struct job {\n2 int start ;\n3 int end ;\n4 unsigned long long int result ;\n5};\nvoid * function(void *ptr) f\n1 struct job * myJob = ( struct job *) ptr ;\n2 for ( int i = myJob -> start ; i <= myJob ->end ; i ++)\n3 {\n4 myJob -> result += (5*( i*i) + 5);\n5 }\n22 / 32C Grundlagen - Threads\nUsage\npthread\npassing Arguments & Joining\nint main()f\n1 struct job job1 = {0 ,500 ,0};\n2 struct job job2 = {501 ,1000 ,0};\n3 pthread_t worker1 ;\n4 pthread_t worker2 ;\n5\n6 pthread_create (& worker1 ,NULL , function ,( void *) & job1 );\n7 pthread_create (& worker2 ,NULL , function ,( void *) & job2 );\n8 pthread_join ( worker1 , NULL );\n9 pthread_join ( worker2 , NULL );\n10 fprintf (stdout ,\" Result : %llu + %llu = % llu \\n\",job1 . result , job2 . result ,(\njob1 . result + job2 . result ));\n23 / 32C Grundlagen - Threads\nUsage\npthread\nMutex\nData Types for pthread\n1pthread_mutex_t mutex\nCreate and Destroy\n1pthread_mutex_init (mutex , attr )\n2pthread_mutex_destroy ( mutex )\nLocking\n1pthread_mutex_lock ( mutex )\n2pthread_mutex_trylock ( mutex )\n3pthread_mutex_unlock ( mutex )\n24 / 32C Grundlagen - Threads\nUsage\npthread\nint transfer(struct account *from, struct account *to, int ammount)\n1 pthread_mutex_lock (& from -> lock );\n2 if(from -> balance > ammount ) {\n3 if( pthread_mutex_trylock (&to -> lock ) == 0) {\n4 from -> balance -= ammount ;\n5 to -> balance += ammount ;\n6 pthread_mutex_unlock (&to -> lock );\n7 } else {\n8 pthread_mutex_unlock (& from -> lock );\n9 return transfer (from ,to , ammount );\n10 }\n11 pthread_mutex_unlock (& from -> lock );\n12 fprintf (stdout ,\"| %s\\t | %d\\t |\\n\",to ->name ,to -> balance );\n13 return 0;\n14 } else {\n15 pthread_mutex_unlock (& from -> lock );\n16 return -1;\n17 }\n25 / 32C Grundlagen - Threads\nUsage\nOpenMP\nOpenMP\nWhat is OpenMP\n\u000fAPI for using multiple threads on MPM\n\u000fSupports C / C++ and Fortran\n\u000fIs a set of compile directives\n\u000fEasy to use\ncompiling\ngcc -std=c11 -fopenmp <\fle> -o <output\fle>\n26 / 32Example\nHello World\n1# include <stdio .h>\n2\n3int main ( void )\n4{\n5 # pragma omp parallel\n6 printf (\"Hello , world .\\n\");\n7 return 0;\n8}C Grundlagen - Threads\nSummary\nTable of Contents\n1Introduction\n2What are threads\n3How to use threads in C\n4Summary\n5Literature\n28 / 32C Grundlagen - Threads\nSummary\nSummary\nWhat we`ve learned\n\u000fWith threads we can access multiple CPU`s\n\u000fCorecctly used they o\u000ber more Performance on MPM\n\u000fWe have to syncronize access to shared data\n\u000fTake care of Race Conditions, Dead locks and Live Locks\n29 / 32C Grundlagen - Threads\nSummary\nThank you for your attention\n30 / 32C Grundlagen - Threads\nLiterature\nTable of Contents\n1Introduction\n2What are threads\n3How to use threads in C\n4Summary\n5Literature\n31 / 32C Grundlagen - Threads\nLiterature\nLiterature\nBlaise Barney.\nPosix threads programming.\nhttps://computing.llnl.gov/tutorials/pthreads/ .\nMany.\nThread (computing).\nhttp://en.wikipedia.org/wiki/Thread_(computing) .\n32 / 32", "language": "PDF", "image": "PDF", "pagetype": "PDF", "links": "PDF"}