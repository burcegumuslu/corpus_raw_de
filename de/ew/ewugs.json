{"title": "PDF", "author": "PDF", "url": "https://sp1718.github.io/objektorientierungI.pdf", "hostname": "PDF", "description": "PDF", "sitename": "PDF", "date": "PDF", "id": "PDF", "license": "PDF", "body": "PDF", "comments": "PDF", "commentsbody": "PDF", "raw_text": "PDF", "text": "Objektorientiertes Programmieren I\nSymbolische Programmiersprache\n.\nBenjamin Roth \u2013 Folien von Annemarie Friedrich\nWintersemester 2017/2018\nCentrum f\u00fcr Informations- und Sprachverarbeitung\nLMU M\u00fcnchen\n1Imperatives / Prozedurales Programmieren\n.\nImperatives Paradigma\nErst tu dies, dann tu das.\n\u2022Kontrollstrukturen de\ufb01nieren die Reihenfolge, in der die\n\u201cRechenschritte\u201d (Programmschritte) ausgef\u00fchrt werden.\n\u2022Was ist ein Rechenschritt in Python?\n\u2022Welche Kontrollstrukturen kennen Sie?\n\u2022Zustand des Programms \u00e4ndert sich als eine Funktion der Zeit.\n\u2022Befehle k\u00f6nnen in Prozeduren (Funktionen) gruppiert werden.\n2Imperatives / Prozedurales Programmieren\n.\n1def cels_to_fahr (c):\n2 f = c*1.8 + 32\n3 return f\n4\n5def fahr_to_cels (f):\n6 c = (f - 32) * 5/9\n7 return c\n8\n9print (\"Enter degrees .\")\n10d = int(input (\">>\"))\n11\n12print (\"CtoF(1)orFtoC(2)?\")\n13option = None\n14\n15while not (option == 1 oroption == 2):\n16 option = int(input (\">>\"))\n3Imperatives / Prozedurales Programmieren\n.\n1ifoption == 1:\n2 f = cels_to_fahr(d)\n3 print (d, \"Care\", f, \"F\")\n4else :\n5 c = fahr_to_cels(d)\n6 print (d, \"Fare\", c, \"C\")\n4Objektorienterte Programmierung\n.\nHigh-level-\u00dcberblick\n5Objektorienterte Programmierung\n.\nObjektorientierung\nSend messages between objects to simulate the\ntemporal evolution of a set of real world phenomena.\n\u2022Klassen beschreiben Konzepte (Daten oder Operationen)\ndes Anwendungsgebiets\n\u2022Methoden (= Prozeduren) sind an diese angegliedert\n\u2022Beispiele: Java, C++, Smalltalk, Python\n6Objektorienterte Programmierung\n.\n\u2022Real-life Objekte werden als Software-Objekte repr\u00e4sentiert.\n\u2022Objekte kombinieren Charakteristika ( Attribute ) und\nVerhaltensweisen ( Methoden ).\nCar\nATTRIBUTES:\nmake\nmodel\ncolor\nwheels\nseats\nautobody\nmotor\nMETHODS:\nstart\ndrive\nstop\nhonk\n7Klassen = Baupl\u00e4ne\n.\n\u2022Klassen sind Baupl\u00e4ne/Designs f\u00fcr Objekte .\n\u2022Objekte mit Hilfe von Klassen erstellen: Wir instanziieren\nobjects.\nObjekte = Instanzen einer Klasse.\n\u2022Objekte einer Klasse haben die gleiche grundlegende Struktur,\nk\u00f6nnen sich aber in verschiedenen Aspekten unterscheiden.\n8Vererbung\n.\n\u2022Verschiedene Objekte haben teilweise dasselbe Verhalten /\ndieselben Charakteristika.\n\u2022Vererbung !Code-Dopplungen vermeiden.\n9Objektorientiertes Programmieren\n.\nDetails ...\n... und Umsetzung in Python.\n10Software-Objekte repr\u00e4sentieren Real-life-Objekte\n.\nAttributeObjektannesAccount stefansAccount\nnumber 1 2\nholder \u2019Anne\u2019 \u2019Stefan\u2019\nbalance 200 1000\nAttribute\n\u2022beschreiben den Zustand des Objekts\n\u2022enthalten die Daten eines Objekts\n\u2022k\u00f6nnen sich im Laufe der Zeit ver\u00e4ndern\n11Klassen = Baupl\u00e4ne f\u00fcr Objekte\n.\n1class Account :\n2 ''' aclass for objects\n3 representing anaccount '''\n4 pass\n5\n6#Main part ofthe program\n7if__name__ == \"__main__ \":\n8 #Creating objects\n9 annesAcc = Account()\n10 stefansAcc = Account()\n11 #Assigning attributes\n12 annesAcc.holder = \"Anne \"\n13 annesAcc.balance = 200\n14 stefansAcc.holder = \"Stefan \"\n15 stefansAcc.balance = 1000\n16 #Accessing attributes\n17 print (annesAcc.balance)\u2022Klassennamen: beginnen\nmit Gro\u00dfbuchstaben\n\u2022pass= \u2019hier passiert gar\nnichts\u2019\n\u2022Objekte weden erstellt, in\ndem \u201cdie Klasse\naufgerufen wird\u201d\n\u2022Zuweisung von / Zugriff\nauf Attribute: dot\nnotation\n12Methoden = Funktionen, die zu einer Klasse geh\u00f6ren\n.\n1class Account :\n2 #METHODS\n3 def deposit (self , amount):\n4 self .balance += amount\n5\n6if__name__ == \"__main__ \":\n7 annesAcc = Account()\n8 annesAcc.balance = 200\n9 annesAcc.deposit(500)\nInstanzmethoden\n\u2022operieren auf Objekten, die von dieser Klasse erstellt wurden\n\u2022Code manipuliert die Attribute des Objekts oder erlaubt den\nZugriff auf diese\n\u2022Erste Parameter: self(Konvention)\n13Methoden = Funktionen, die zu einer Klasse geh\u00f6ren\n.\n1class Account :\n2 #METHODS\n3 def deposit (self , amount):\n4 self .balance += amount\n5\n6if__name__ == \"__main__ \":\n7 annesAcc = Account()\n8 annesAcc.balance = 200\n9 annesAcc.deposit(500)\nInstanzmethoden\n\u2022wenn diese \u201cvon einem Objekt aus\u201d aufgerufen werden (Zeile 9):\n\u2022entsprechende Methode wird in der Klasse, von der das Objekt\nerstellt wurde, aufgerufen\n\u2022das Objekt wird automatisch dem Parameter selfzugewiesen\n\u2022Zeile 9 ist \u00e4quivalent mit: Account.deposit(annesAccount, 500)\n14Methoden = Funktionen, die zu einer Klasse geh\u00f6ren\n.\n1class Account :\n2 #METHODS\n3 def withdraw (self , amount):\n4 self .balance -= amount\n5 def deposit (self , amount):\n6 self .balance += amount\n7 def print_info (self ):\n8 print (\"Balance :\",self .balance)\n9\n10if__name__ == \"__main__ \":\n11 annesAcc = Account()\n12 annesAcc.balance = 200\n13 annesAcc.deposit(500)\n14 annesAcc.withdraw(20)\n15 annesAcc.print_info()\n15Objekte sind mit ihren Klassen \u201cverlinkt\u201d\n.\n\u2022annesAcc.deposit(500)\n\u2022Python f\u00e4ngt im Objekt an, die Methode zu suchen (technisch\ngesehen k\u00f6nnen Methoden auch f\u00fcr individuelle Objekte\nde\ufb01niert werden \u2013 praktisch werden sie immer in Klassen\nde\ufb01niert\u0003)\n\u2022Methode wird in Klasse, von der das Objekt erstellt wurde,\ngesucht\n\u0003Klassen sind auch Objekte in Python: aber dazu kommen wir sp\u00e4ter. ,\n16UML Klassen-Diagramme\n.\n\u2022Uni\ufb01ed Modeling Language\n\u2022Visualisierungs-Standard f\u00fcr objektorientierte Programmierung\n(und mehr)\nName of the class\nAttributes\nMethodsAccount\nid\nholder\nbalance\ndeposit(amount)\nwithdraw(amount)\n17Attribute m\u00fcssen existieren, wenn auf sie zugegriffen wird\n.\n1class Account :\n2 def print_info (self ):\n3 print (\"Balance :\",self .balance)\n4\n5if__name__ == \"__main__ \":\n6 stefansAcc = Account()\n7 stefansAcc.print_info()\nWarum wirft dieser Code einen Fehler?\n18Initalisierung / Konstruktor\n.\n1class Account :\n2 #CONSTRUCTOR\n3 def __init__ (self , num, person):\n4 self .balance = 0\n5 self .number = num\n6 self .holder = person\n7 #METHODS\n8 ...\n9\n10if__name__ == \"__main__ \":\n11 annesAcc = Account(1, \"Anne \")\n12 stefansAcc = Account(2, \"Stefan \")\n\u2022__init__(self) wird automatisch nach Erstellen des Objekts\naufgerufen\n\u2022Konstruktor /Initialisierungs- Methode weist Attributen des\nObjekts initiale / Default-Werte zu\n19Initalisierung / Konstruktor\n.\n1annesAcc = Account(1, \"Anne \")\n1.Neues Objekt der Klasse Account wird erstellt & und der Variable\nannesAcc zugewiesen\n2.Die Initialisierungsmethode von Account wird aufgerufen\nVariable selfzeigt dabei auf das neue Objekt\ntechnisch: Account.__init__(annesAcc, 1, \"Anne\")\n3.In der Initalisierungsmethode wird das Objekt initialisiert\n(Attribute werden auf die gegebenen oder auf Default-Werte gesetzt).\n20Klassendesign\n.\nRegeln f\u00fcr gutes Klassendesign\n1.Wie kann ich den Zustand meines Objekts bescheiben?\n)Attribute .\n2.Was wei\u00df ich \u00fcber mein Objekt beim oder vor dessen\nErstellen?\n)Initialisierungsmethode .\n3.Welche Operationen, die den Zustand des Objekts\n\u00e4ndern, werden auf dieses (im Lauf der Zeit) angewandt?\n)Instanzmethoden .\nWas sind die Antworten f\u00fcr das Konto-Beispiel?\n21\u00dcbung: Klassendesign\n.\nZeichen Sie ein UML-Klassendiagamm f\u00fcr folgende Anwendung.\n\u2022Objekte sollen die Angestellten (bzw. deren Akten) einer\nUniversit\u00e4t repr\u00e4sentieren.\n\u2022Welche Attribute haben die Angestellten?\n\u2022Welche Methoden werden auf die Akten angewendet? (Tipp: die\nAngestellten k\u00f6nnen eine Gehaltserh\u00f6hung erhalten, sie k\u00f6nnen\nheiraten und ihren Namen \u00e4ndern, ...)\n22Attribute nur in Instanzmethoden manipulieren\n.\nSchlechter Stil: stefansAcc.balance = 1000\nDatenkapselung (data encapsulation)\n\u2022Attibute eines Objekts sollten vor Manipulationen \u201cvon au\u00dfen\u201d\n(= von Code, der das Objekt benutzt) \u201cversteckt\u201d sein\n\u2022Attribute eines Objekts sollten nur von Code, der innerhalb der\nKlasse de\ufb01niert ist, modi\ufb01ziert werden\n\u2022Dies stellt sicher, dass der Zustand des Objekts immer valide ist\nBeispiel\n\u2022Konto mit Au\ufb02age: Kontostand darf nicht negativ sein\n\u2022Stefans Kontostand ist $1000, er will $1500 abheben\n\u2022Schalterbeamter zahlt aus und setzt Stefans Kontostand auf\n-$500)Bankmanager sauer\n23Bankmanager gl\u00fccklich machen\n.\n1class Account :\n2 #METHODS\n3 def withdraw (self , amount):\n4 ifamount > self .balance:\n5 amount = self .balance\n6 self .balance -= amount\n7 return amount\n8 ...\n9\n10if__name__ == \"__main__ \":\n11 stefansAcc = Account(2, \"Stefan \")\n12 stefansAcc.deposit(1000)\n13 cash = stefansAcc.withdraw(1500)\n14 print (\"Ohno,Ionly got:\", cash)\n24Attribut-Werte \u00e4ndern: Setter-Methoden\n.\n1class Account :\n2 def set_holder (self , person):\n3 self .holder = person\n4\n5if__name__ == \"__main__ \":\n6 stefansAcc = Account(2, \"Stefan \")\n7 stefansAcc.deposit(1000)\n8 stefansAcc.set_holder( \"Andrea \")\n\u2022F\u00fcr jedes Attribut, das von au\u00dfen ge\u00e4ndert werden muss, eine\nSetter-Methode bereitstellen\n\u2022Erlaubt Validierung\n25Attribut-Werte \u00e4ndern: Setter-Methoden\n.\nBeispiel f\u00fcr Validierung in einer Setter-Methode:\n1def set_holder (self , person):\n2 if(not type (person) == str):\n3 raise TypeError\n4 ifnot re.match( \"\\w+(\\w+)*\", person.strip()):\n5 raise ValueError\n6 self .holder = person\n26Datenkapselung\n.\nCoding Style Regeln\n1.Attributen Werte nur in Instanzmethoden\n(Setter-Methoden) oder im Konstruktor zuweisen.\n2.Die Werte von Attributen nur \u00fcber Instanzmethoden\nmodi\ufb01zieren.\n3.Zugriff auf (Lesen von) Attributwerten mit\nprint(stefansAcc.balance) ist okay.\nHinweis - eine weitere M\u00f6glichkeit in Python: properties\n27String-Repr\u00e4sentation eines Objekts\n.\n1class Account :\n2 def __str__ (self ):\n3 res = \"*** Account Info ***\\ n\"\n4 res += \"Account ID:\"+str(self .number) + \"\\n\"\n5 res += \"Holder :\"+self .holder + \"\\n\"\n6 res += \"Balance :\"+str(self .balance) + \"\\n\"\n7 return res\n8\n9if__name__ == \"__main__ \":\n10 annesAcc = Account(1, \"Anne \")\n11 annesAcc.deposit(200)\n12 print (annesAcc)\n\u2022Hooks = Methoden, die von Python in bestimmten Situationen\nautomatisch aufgerufen werden\n\u2022hier: wird eine String-Repr\u00e4sentation des Objekts ben\u00f6tigt?\nz.B.print(annesAcc) oder str(annesAcc)\n28\u00dcbung 1 (siehe \u00dcbungsblatt)\n.\n\u2022Using the slides & the script, put together a \ufb01le containing the\ncomplete Account class and create a main application where\nyou create a number of accounts.\n\u2022Play around with depositing / withdrawing money.\n\u2022Change the account holder of an account using a setter method.\n\u2022Change the withdraw function such that the minimum balance\nallowed is -1000.\n\u2022Write a function apply_interest(self) which applies an\ninterest rate of 1.5% to the current balance and call it on your\nobjects.\n29\u00dcbung 2 (siehe \u00dcbungsblatt)\n.\n\u2022Write the complete code for the Employee class (including\nconstructor, __str__ ,...)\n\u2022Create a few employee objects and show how you can\nmanipulate them using the methods.\n\u2022Draw a UML class diagram for your Employee class.\n30Literatur\n.\nMark Lutz: Learning Python , Part VI, 4th edition, O\u2019Reilly, 2009.\nMichael Dawson: Python Programming for the Absolute Beginner ,\nChapters 8 & 9, 3rd edition, Course Technology PTR, 2010.\nhttp://people.cs.aau.dk/~normark/prog3-03/html/notes/\nparadigms_themes-paradigm-overview-section.html\n31", "language": "PDF", "image": "PDF", "pagetype": "PDF", "links": "PDF"}