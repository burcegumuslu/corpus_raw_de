{"title": "PDF", "author": "PDF", "url": "https://sp1718.github.io/03_objects_modules.pdf", "hostname": "PDF", "description": "PDF", "sitename": "PDF", "date": "PDF", "id": "PDF", "license": "PDF", "body": "PDF", "comments": "PDF", "commentsbody": "PDF", "raw_text": "PDF", "text": "Objektorientiertes Programmieren II\nSymbolische Programmiersprache\n.\nBenjamin Roth \u2013 Folien von Annemarie Friedrich\nWintersemester 2017/2018\nCentrum f\u00fcr Informations- und Sprachverarbeitung\nLMU M\u00fcnchen\n1Recap: Software-Objekte repr\u00e4sentieren Real-life-Objekte\n.\nAttributesObjectannesAccount stefansAccount\nnumber 1 2\nholder \u2019Anne\u2019 \u2019Stefan\u2019\nbalance 200 1000\nAttribute\n\u2022beschreiben den Zustand des Objekts\n\u2022enthalten die Daten eines Objekts\n\u2022k\u00f6nnen sich im Laufe der Zeit ver\u00e4ndern\n2Recap: Zugriff auf Attribute mit der dot notation\n.\n1annesAcc = Account()\n2stefansAcc = Account()\n3annesAcc.balance = 200\n4stefansAcc.holder = \"Stefan \"\n5someVariable = stefansAcc\n6print (someVariable.holder)\n7someVariable.balance = 50\n8print (stefansAcc.balance)\n3Recap: Methoden manipulieren die Daten eines Objekts\n.\n1class Account :\n2 def __init__ (self , num, holder):\n3 self .num = num\n4 self .holder = holder\n5 self .balance = 0\n6 def deposit (self , amount):\n7 self .balance += amount\n8 def withdraw (self , amount):\n9 ifself .balance < amount:\n10 amount = self .balance\n11 self .balance -= amount\n12 return amount\n13 def __str__ (self ):\n14 return \"[Account \"+self .num \\\n15 +\"\"+self .holder + \"\"\\\n16 +self .balance + \"]\"\n4Recap: Methoden werden \u201cauf einem Objekt\u201d aufgerufen\n.\n1annesAcc.deposit(200)\n2stefansAcc.deposit(1000)\n3someVariable.withdraw(300)Instanzmethoden\nDas Objekt, auf dem die Methode\naufgerufen wird, wird dem\nParameter selfzugewiesen.5Recap: Konstruktor / Initialisierungsmethode\n.\n\u2022wird gleich nach Erzeugen eines neuen Objekts aufgerufen\n(selfzeigt auf das neue Objekt)\n\u2022numund holder sind lokale Variablen der Methode\n\u2022self.num und self.holder sind Attribute des Objekts\n\u2022Verschiedene Namespaces )verschiedene Variablen!\n\u2022!Tafel\n1class Account :\n2 #Constructor\n3 def __init__ (self , num, holder):\n4 self .num = num\n5 self .holder = holder\n6 self .balance = 0\n7\n8annesAcc = Account(1, \"Anne \")\n9stefansAcc = Account(2, \"Stefan \")\n6Python Modules\n.\n\u2022Modules sind einfach Dateien mit Python-Code, k\u00f6nnen Funktionen,\nVariablen, Klassen oder ausf\u00fchrbaren Code de\ufb01nieren.\n\u2022Module gruppieren zusammengeh\u00f6rigen Code !Verst\u00e4ndlichkeit\n\u2022De\ufb01nition von Klasse / Funktion !Python erstellt Funktions-/Klassenobjekt\n\u2022Module sind auch Objekte, beinhalten Referenzen auf die\nFunktions-/Klassenobjekte, die das Modul de\ufb01niert. Wir k\u00f6nnen diese\nFunktionen/Klassen in anderen Modulen (=Python-Dateien) importieren .\n\u2022Modulname = Dateiname ohne .py\n1#import all functions /classes from <modulename >\n2import modulename\n3\n4#import specific function\n5from modulename import somefunction\n6\n7#import specific class\n8from modulename import someclass\nhttp://www.tutorialspoint.com/python/python_modules.htm7Python Modules\n.\n\u2022Wenn ein Modul importiert wird, sind dessen\nFunktionen/Klassen verf\u00fcgbar.\n\u2022Ein Modul ausf\u00fchren: python3 someModule.py (or F5 in IDLE)\n\u2022someModule kann auch Code aus anderen Dateien importieren.\n\u2022if-Statement (s.u.) checkt, ob das Modul als main module\nausgef\u00fchrt wird. )Tests f\u00fcr das Modul hierhin schreiben, beim\nAusf\u00fchren ist nur das main module relevant!\n1#imports\n2\n3#some more function /class definitions\n4\n5#main\n6if__name__ == \"__main__ \":\n7 #this code isexecuted when running THIS module\nhttp://www.tutorialspoint.com/python/python_modules.htm\n8Projektstrukturierung\n.\n\u2022Klassen in separate Dateien.\n\u2022Klassende\ufb01nition z.B. in accounts.py\n\u2022Klassen in der Haupt-Anwendung importieren\n\u2022from modulename import classname\n\u2022modulename = Dateiname, in dem die Klasse de\ufb01niert ist (ohne\n.py)\n\u2022classname = Name der Klasse\n1from accounts import Account\n2\n3if__name__ == \"__main__ \":\n4 annesAcc = Account()\n5 annesAcc.balance = 200\n9Typen von Objekten\n.\n\u2022Werte in Python haben Typen :\n\u20221.5hat Typ \ufb02oat\n\u2022'Stefan' hat Typ str\n\u2022Der Typ des Instanzobjekts stefansAcc ist die Klasse, von dem es\nerstellt wurde\n1>>> stefansAcc = Account(2, \"Stefan \")\n2>>> type (stefansAcc)\n3<class '__main__ .Account '>\n10Komposition/Aggregation\n.\n\u2022Komposition : Katze - Bein. Das Bein existiert nur, wenn die\nganze Katze existiert.\n\u2022Aggregation : Vorlesung Python - Student. Der Student existiert\nauch, wenn es die Vorlesung nicht gibt.\n11Komposition/Aggregation\n.\n\u2022Die Attribute eines Objekts k\u00f6nnen irgendeinen Typ haben\n\u2022Sie k\u00f6nnen auch selbst (komplexe) Objekte sein\n\u2022Komposition = komplexe Objekte werden aus mehreren\nObjekten zusammengebaut, die \u201centhaltenen\u201d Objekte\nexistieren nur innerhalb des komplexen Objekts\n\u2022Aggregation = keine exklusive Zugeh\u00f6rigkeit impliziert\n\u2022Zugriff mit dot notation :annesAcc.holder.name\n\u2022Diese Aufrufe nicht zu lang machen! (Lesbarkeit und Sicherheit)\n12Aggregation: Beispiel\n.\n1class Person :\n2 def __init__ (self , f, l, a):\n3 self .firstname = f\n4 self .lastname = l\n5 self .age = a\n6\n7class Account :\n8 def __init__ (self , person, num):\n9 self .holder = person\n10 self .num = num\n11 self .balance = 0\n12 def deposit (self , amount):\n13 self .balance += amount\n14\n15anne = Person( \"Anne \",\"Friedrich \", 95)\n16annesAcc = Account(anne, 1)\n17annesAcc2 = Account(anne, 2)\n13Aggregation: Shared References\n.\n\u2022Aufpassen, wohin die Attribute zeigen:\n\u2022annesAcc.holder.age += 1 \u00e4ndert auch\nannesAcc2.holder.age\n\u2022Hier ok, aber aufpassen, damit keine Bugs erzeugt werden!\n14Aggregation: UML Diagram\n.\n15References\n.\nMark Lutz: Learning Python , Part VI, 4th edition, O\u2019Reilly, 2009.\nMichael Dawson: Python Programming for the Absolute Beginner ,\nChapters 8 & 9, 3rd edition, Course Technology PTR, 2010.\n16", "language": "PDF", "image": "PDF", "pagetype": "PDF", "links": "PDF"}